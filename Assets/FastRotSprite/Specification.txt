Fast RotSprite - simple rotation for pixel art in runtime developed by Oleg Mekekechko for Pixel Studio app.

INTRODUCTION.

At first you should realize that pixel art rotation is not a trivial operation. There are no "true" deterministic algorithms.
Different algorithms produce different results, but in most cases manual correction is required.
Basically there is RotSprite method suggested by Xenowhirl. The main idea is to upscale an image before rotating. And then to apply "guessing" pixel patterns to fix the resulting image.
Unfortunately, there is no public specification provided by Xenowhirl. His description may be interpreted ambiguously and requires some "voodoo dancing".
Also it should be taken into account that Xenowhirl has developed RotSprite to rotate sprites to 45 degrees for his game. RotSprite performance was no matter.

Thus there was a need in fast and efficient rotation algorithm with the following features:
- it should work fast even on mobile devices (in runtime without FPS drop)
- it should work with large images (taken into account that x3/x8 upscaling is used)
- some quality loss is acceptable (compared to RotSprite)

SPECIFICATION.
1. Upscale the image using Scale3x algorithm. More info: https://www.scale2x.it/algorithm
1a. When upscaling you should modify the algorithm by introducing Threshold to compare colors. By default Threshold is 0.05 (5% for all RGBA components).
1b. Note that most mobile devices support images up to 4096x4096 px (and some up to 2048x2048 px). Keep this in mind when upscaling!

2. Rotate the upscaled image.
2a. Convert each pixel to Polar coordinates.
2b. Apply rotation to [angle].
2c. Convert Polar coordinates to Cartesian coordinates.
2d. Ignore pixels outside the image bounds.
2e. The rotated image will inevitably have a [grid of empty pixels] because 2 pixels may be translated to the same position after rotation. This means that some image data will be lost after rotation.

3. Downscale the image.
3a. Split the upscaled image to 3x3 nodes and then convert each node to a single pixel. Calculate an average RGBA color and then search for the nearest pixel in the node. In any case, you shouldn't introduce new colors!
3b. Example: if we have 3 [white], 1 [gray] and 4 [black] pixels, the resulting pixel will be [gray].

VARIATIONS.

1. UPSCALE VARIATION.
Upscale the image with Scale2x three times (resulting x8 upscale as in RotSprite). When upscaling you should modify the algorithm by introducing Threshold to compare colors. Note that x8 scale will work ~7 times slower than x3 (processing 8x8 nodes vs 3x3 nodes).

2. ROTATION VARIATION.
To avoid appearing of a [grid of empty pixels] you can revert rotation. Translate final pixels to original pixels by applying -[angle] rotation. This means that some image data will be duplicated (instead of loss).

3. DOWNSCALE VARIATION.
Split the upscaled image to 3x3 (or 8x8) nodes and then convert each node to a single pixel. Select the most frequent pixel.
Example: if we have 3 [white], 1 [gray] and 4 [black] pixels, the resulting pixel will be [black].

NOTES.
To speed up the performance you can use threads for upscaling, rotation and downscaling.
You can try different scaling and rotation algorithms for achieving better results.
Aseprite (pixel art editor) uses its' own implementation of RotSprite, but it works very slow.

PERFORMANCE EXAMPLE.
Image sample 64x64 px, Ryzen 5 2500U CPU (4C/8T), default implementation with C# (Unity 2018). 1 rotation operation performs at 30 ms.

CONTACT.
hippogamesunity@gmail.com